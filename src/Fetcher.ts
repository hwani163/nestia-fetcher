import { IConnection } from "./IConnection";
import { IEncryptionPassword } from "./IEncryptionPassword";
import { Primitive } from "./Primitive";

import { AesPkcs5 } from "./AesPkcs5";
import { HttpError } from "./HttpError";

// POLYFILL FOR NODE
if (typeof global === "object"
    && typeof global.process === "object" 
    && typeof global.process.versions === "object"
    && typeof global.process.versions.node !== undefined)
(global as any).fetch = require("node-fetch");

/**
 * Fetcher, utility class for the [**Nestia**](https://github.com/samchon/nestia) fetch.
 * 
 * `Fetcher` is a utility class providing the {@link Fetcher.fetch} functions who're being 
 * used by all of the SDK libraries, interacting with the remote HTTP servers, who are 
 * generated by the [**Nestia**](https://github.com/samchon/nestia).
 * 
 * As this `Fetcher` be used only by the [**Nestia**](https://github.com/samchon/nestia) 
 * generated SDK libraries, you don't need to handle this class directly. It may only be 
 * appeared in the source codes of the [**Nestia**](https://github.com/samchon/nestia) 
 * generated SDK libraries.
 * 
 * @author Jeongho Nam - https://github.com/samchon
 */
export class Fetcher
{
    /**
     * Fetch function for the `GET` or `DELETE` methods.
     * 
     * @param connection Connection information for the remote HTTP server
     * @param encrypted Whether the request/response body be encrypted or not
     * @param method Method of the HTTP request
     * @param path Path of the HTTP request
     * @return Response body data from the remote HTTP server
     */
    public static fetch<Output>
        (
            connection: IConnection, 
            encrypted: Fetcher.IEncrypted, 
            method: "GET" | "DELETE", 
            path: string
        ): Promise<Primitive<Output>>;

    /**
     * Fetch function for the `POST`, `PUT` and `PATCH` methods.
     * 
     * @param connection Connection information for the remote HTTP server
     * @param encrypted Whether the request/response body be encrypted or not
     * @param method Method of the HTTP request
     * @param path Path of the HTTP request
     * @param input Request body data for the HTTP request
     * @return Response body data from the remote HTTP server
     */
    public static fetch<Input, Output>
        (
            connection: IConnection, 
            encrypted: Fetcher.IEncrypted, 
            method: "POST" | "PUT" | "PATCH", 
            path: string, 
            input: Input
        ): Promise<Primitive<Output>>;

    public static async fetch<Output>
        (
            connection: IConnection, 
            encrypted: Fetcher.IEncrypted, 
            method: "GET" | "DELETE" | "POST" | "PUT" | "PATCH", 
            path: string, 
            input?: object
        ): Promise<Primitive<Output>>
    {
        if (encrypted.request === true || encrypted.response === true)
            if (connection.encryption === undefined)
                throw new Error("Error on nestia.Fetcher.encrypt(): the encryption password has not been configured.");

        //----
        // REQUEST MESSSAGE
        //----
        // METHOD & HEADERS
        const init: RequestInit = {
            method,
            headers: encrypted.request === false && input !== undefined && typeof input === "object"
                ? { 
                    ...connection.headers,
                    "Content-Type": "application/json"
                }
                : connection.headers
        };

        // REQUEST BODY (WITH ENCRYPTION)
        if (input !== undefined)
        {
            let content: string = JSON.stringify(input);
            if (encrypted.request === true)
            {
                const password: IEncryptionPassword | IEncryptionPassword.Closure = connection.encryption instanceof Function
                    ? connection.encryption!(content, true)
                    : connection.encryption!;
                if (is_disabled(password, content, true) === false)
                    content = AesPkcs5.encrypt(content, password.key, password.iv);
            }
            init.body = content;
        }

        //----
        // RESPONSE MESSAGE
        //----
        // URL SPECIFICATION
        if (connection.host[connection.host.length - 1] !== "/" && path[0] !== "/")
            path = "/" + path;
        
        const url: URL = new URL(`${connection.host}${path}`);

        // DO FETCH
        const response: Response = await fetch(url.href, init);
        let content: string = await response.text();

        if (!content)
            return undefined!;

        // CHECK THE STATUS CODE
        if (response.status !== 200 && response.status !== 201)
            throw new HttpError(method, path, response.status, content);

        // FINALIZATION (WITH DECODING)
        if (encrypted.response === true)
        {
            const password: IEncryptionPassword | IEncryptionPassword.Closure = connection.encryption instanceof Function
                ? connection.encryption!(content, false)
            : connection.encryption!;
            if (is_disabled(password, content, false) === false)
                content = AesPkcs5.decrypt(content, password.key, password.iv);
        }

        //----
        // OUTPUT
        //----
        let ret: { __set_headers__: Record<string, any> } & Primitive<Output> = content as any;
        try
        {
            // PARSE RESPONSE BODY
            ret = JSON.parse(ret as any);

            // FIND __SET_HEADERS__ FIELD
            if (ret.__set_headers__ !== undefined && typeof ret.__set_headers__ === "object")
            {
                if (connection.headers === undefined)
                    connection.headers = {};
                Object.assign(connection.headers, ret.__set_headers__);
            }
        }
        catch {}

        // RETURNS
        return ret;
    }
}

export namespace Fetcher
{
    /**
     * Whether be encrypted or not.
     * 
     * `Fetcher.IEncrypted` is a type of interface who represents whether the HTTP request 
     * and response body must be encrypted or not. 
     * 
     * Like the {@link Fetcher} who are being used by all of the SDK libraries that are 
     * generated by the [Nestia](https://github.com/samchon/nestia), this `IEncrypted` 
     * interface would be used by the [Nestia](https://github.com/samchon/nestia) generated 
     * SDK libaries.
     * 
     * As this `Fetcher` be used only by the [**Nestia**](https://github.com/samchon/nestia) 
     * generated SDK libraries, you don't need to handle this class directly. It may only be 
     * appeared in the source codes of the [**Nestia**](https://github.com/samchon/nestia) 
     * generated SDK libraries.
     */
    export interface IEncrypted
    {
        /**
         * Whether the request body be encrypted or not.
         */
        request?: boolean;

        /**
         * Whether the response body be encrypted or not.
         */
        response: boolean;
    }
}

function is_disabled(password: IEncryptionPassword, content: string, encoded: boolean): boolean
{
    if (password.disabled === undefined)
        return false;
    else if (typeof password.disabled === "function")
        return password.disabled(content, encoded);
    else
        return password.disabled;
}